# Day6. バリデーション

画面が整ってきたところで、次はバリデーションを実施して、
不正な値入力に耐えられるシステムを構築してみましょう。

## 本章の目標

- 

## 8 11.19 バリデーション

これまで作成してきたタスクリストはそのままでも動かすことはできますが、
空の文字を入れたときなどにエラーとなってしまいます。

入力データが適切な値で有るかチェックする処理をバリデーションと呼び、
バリデーションを行うことで、データベースへ不正な値が入ることを防いだり、
適切な値を入力するよう促したりすることが出来るようになっています。

簡単なバリデーションの実装例を見てみましょう。

```
Route::post("/task",function(){
    $rules = [
        "task_name" => ["required","max:10"]
    ];
    $val = validator(request()->all(),$rules);

    if($val->fails()){
        session()->flash("OLD_INPUTS",request()->all());
        session()->flash("FORM_ERRORS",$val->errors());
        return redirect("/tasklist");
    }

    
    $taskName = request()->get("task_name");
    DB::insert("insert into tasks (name) values (?)",[$taskName]);
    return redirect("/tasklist");
});
```

フォームの処理の前にバリデーションの処理が含まれています。

`validator` 関数はバリデーション処理を行うための関数で、

前回実装した `POST /order` と比べると処理の前にフォーム値のチェックが追加されているのがわかります。

ここでは、 `name` `address` が空の場合に、もとの画面にリダイレクトし、注文を完了できないようにしています。

このままでは、なぜ戻されたのかわかりません。セッションにメッセージを追加してみましょう。


```
Route::post("/order",function(){

    if(request()->get("name") == ""){
        session()->put("FORM_MESSAGE","名前を入力してください");
        return redirect("/order");
    }
    if(request()->get("address") == ""){
        session()->put("FORM_MESSAGE","住所を入力してください");
        return redirect("/order");
    }

    ....
   
    return redirect("/order/thanks");
});
```

この様にリダイレクトと合わせて、`GET /order` 側の画面で `session()->get("FORM_MESSAGE")` のようにすることで、
エラーの原因となるメッセージが取り出せるようになりました。

ただし、一度エラーが起きるとエラーメッセージが出っぱなしになります。`GET /order` のルート内でセッションをクリアするのを忘れないようにしておきましょう。

フォーム内で複数のエラーが発生している場合、まとめて表示してほしいと思うかもしれません。
上記の方法では、名前、住所、一つづつのエラーしか表示してくれません。

複数のエラーをまとめてチェックするには、エラーのチェック状態を一時的に保存する変数を使って以下のように記述すると良いでしょう。

```
Route::post("/order",function(){

    $error = false; //フォームにエラーが有るかどうか
    $errorMessage = []; // エラーメッセージ

    if(request()->get("name") == ""){
        $error = true;
        $errorMessage[] = "名前を入力してください";
    }
    if(request()->get("address") == ""){
        $error = true;
        $errorMessage[] = "名前を入力してください";
    }
    
    if($error){
        session()->put("FORM_MESSAGES",$errorMessage);
        return redirect("/order");    
    }

    ....
   
    return redirect("/order/thanks");
});
```

`$error` はエラーが発生しているかどうかを示します。空のフォームがあれば直ちに `true`がセットされ、最後にもとのフォームに戻すかの判定に使われます。

エラーが発生している場合には、 `$errorMessage` にエラーの内容を格納します。フォームでは複数のエラーが発生する可能性が有るため、エラーメッセージは 配列で用意され最後にセッションに格納されています。

複数のエラーをまとめて処理できる様になったものの、エラーが発生するたびに前回の入力内容が消えてしまうのはとても面倒です。

このあたりも改善して見ましょう。

```
Route::post("/order",function(){

    $error = false; //フォームにエラーが有るかどうか
    $errorMessage = []; // エラーメッセージ

    if(request()->get("name") == ""){
        $error = true;
        $errorMessage[] = "名前を入力してください";
    }
    if(request()->get("address") == ""){
        $error = true;
        $errorMessage[] = "名前を入力してください";
    }
    
    if($error){
        session()->put("FORM_MESSAGES",$errorMessage);
        session()->put("OLD_FORM",request()->all());
        return redirect("/order");    
    }

    ....
   
    return redirect("/order/thanks");
});
```

リダイレクト処理の前に `OLD_FORM` という名前でセッションを利用しています。
`request()->all()` は全てのフォーム項目を取得する関数で、ここでは、フォーム全体の内容をセッションに格納していることになります。

`GET /order` の方では以下のように実装してみましょう。

```
Route::get("/order",function(){
    $errors = session()->get("ERRRO_MESSAGES",[]);
    $inputs = session()->get("OLD_FORM",[]);
    session()->get("ERROR_MESSAGES");
    session()->get("OLD_FORM");
    return view("order",[
        "inputs" => $inputs,
        "errors" = $errors
    ]);
});
```

セッションで格納した情報を取得し、テンプレートに受け渡します。
以前のフォーム状態を再現するには、 input タグを以下のように記述すると良いでしょう。


```
<form action="/order" method="POST">
    <?=csrf_field()?>
    名前：<input type="text" name="name" value="<?=$inputs["name"]??''?>">
    住所：<input type="text" name="address" value="<?=$inputs["name"]??''?>">
    電話番号：<input type="text" value="" name="tel">
    Email：<input type="text" value="" name="email">
    <input type="submit" value="注文">
</form>
```

form の value 属性に フォームデータ `$inputs` の情報を渡しています。

`$inputs` はセッションにデータが入っていない場合、空の配列となる可能性が有るので、
単純に `value="<?=$inputs["name"]?>"`と記述してはエラーとなってしまいます。

ナルコーラスオペレータの`??`を利用して `value="<?=$inputs["name"]??''?>"` のようにすることで
エラーを防ぎ初期値を与えることができます。

今回はバリデーションとして簡単な入力チェックを行いましたが、
実際のバリデーションでは、より複雑なチェックが求められます。

複雑な入力規則のチェックには 正規表現と呼ばれる表現が用いられます。PHPでは preg_match 関数を用いて正規表現のチェックを行うことが可能で、例えば Emailの項目が正しい Email 形式で有るか、とったチェックには、

```
$pattern = "/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/";
if(preg_match($pattern,request()->get("email")) !== 1){
    $error = true;
    $errorMessage[] = "Email形式が不正です。";
}
```

と言ったコードが用いられます。

正規表現の記述は複雑で奥が深いですが、多くのプログラミング言語で利用可能なため、是非一度挑戦してみてください。

またバリデーションに関しては、 Laravel 側で用意されているバリデーションの機能もありますので、そちらの内容もチェックしてみてください。

https://laravel.com/docs/5.7/validation
